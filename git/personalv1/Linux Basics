/etc/apt , /etc/apk : all are packages repos folders (Answer 1)

git installation rhel
subscription manager

resolev path and env confusion

HOW TO CHANGE THE JAVA VERSION IN LINUX?
 # update-alternatives –config java

There are 2 programs which provided ‘java’.

Selection Command

———————————————–

1. /usr/lib/jvm/jre-1.4.2-gcj/bin/java

*+ 2 /usr/lib/jvm/jre-1.6.0-openjdk/bin/java


why we define enviornment variable at $PATH - bcz when we type commands, linux first search $PATH, if you want to run command from current directoyry than start with ./ (3)

how ssh and sshd works :

ssh_config : ssh client configuration, when we try to ssh into remote,  this files is parsed

sshd_config : ssh daemon configurAtion, when a remote connection is made to host, for incoming requests

if PublicKey authentication YES : ssh connection will look for file at authroised_keys ~/.ssh/ folder

how enviornment var and path var works

/etc/profile-->~/.bash_profile-->~/.bashrc

bashrc : functions and aliases

bash_profile/profile: enviornemnt specific varible

To set enviornment varibale for user specific all sessions : You can add it to your shell configuration file, e.g. $HOME/.bash_profile-->which also call bashrc, so if you write in bashrc, its the same 

For all the users and sessions : more globally in /etc/environment.

HOW HTTPS WORKS :

HTTP --> SSL layer on top of it

1. client hello --> server(check version and other things)--> server respond back hello -----> handshake(connection) occurs btween client and server

2. Now serve has to prove identity as it is https --> cleint checks cert at /etc/ssl/certs --> verify if trusted from SCA's , aatched to domain  to which client calling ---> also sometimes client has to show ssl/certs

3. Key excahnge --> encryption of mesasge between them using single key to which both client and server agreed upon

client --> generate random key using public key which got from /ssl/certs --> send encryption key to server--> decrypted by ssl private key--> https connection occurs--> send mesage --> encrypts--> client decrypts


STDIN - keyboard redirection = < file descriptor =0
STDOUT - keyboard redirection = > file descriptor =1
STDERROR - keyboard redirection = 2> file descriptor =2

So if you run a command, that command would expect input from the keyboard, and it would normally send its output to the monitor of your computer without making a difference between normal output and errors. Some commands, however, are started at the background and not from a current terminal session, so these commands do not have a monitor or console session to send their output to, and they do not listen to keyboard input to accept their standard input. That is where redirection comes in handy.

Programs started from the command line have no idea what they are reading from or writing to. They just read from channel (file descriptor) 0 if they want to read from standard input, and they write to file descriptor number 1 to display output and to file descriptor 2 if they have error messages to be output. By default, these are connected to the keyboard and the screen(7). If you use redirection symbols such as <, >, and |, the shell connects the file descriptors to files or other commands. We first look at < and >. Later we discusspipes (using the | symbol).

Redirection is wrting(i.e redirecting ) STDERROR or STDOUT to another files or STDOUT, its end result will always be STDOUT, while Pipes convert one STDOUT to STDIN for another command, that's why redirection is used with files and pipes with command(9)

File descriptor is a channel through which command IN and OUT, it decides where to go, STDOUT or STDERROR(5)

> same as 1>    Redirects to STDOUT, writes to files
>> same as 1>>  Redirects to STDOUT, aappends to files
2> redirect STDERR
2>& 1  Redirects STDERR to the same destination as STDOUT.
< redirect STDIN

STDOUT>FILE
STDOUT 2> FILE --> Only redirects STDERRRO to FILE
STDOUT 2>&1 FILE  --> will not write to FILE, instead TWO STDOUT, (12-18) 

once filedescriptor goes to STDOUT, it will look for another STDIN from command line, if no STDIN than exists.

You can also redirect to device files. A device file on Linux is a file that is used to access specific hardware. Your hard disk for instance can be referred to as / dev/sda, the console of your server is known as /dev/console or /dev/tty1, if you want to discard a commands output, you can redirect to /dev/null.(20)

Where an I/O redirector is used to use alternatives for keyboard and computer monitor, a pipe can be used to catch the output of one command and use that as input for a second command. If a user runs the command ls, for instance, the output of the command is shown onscreen. If the user uses ls | less, the commands ls and less are started in parallel. The standard output of the ls command is connected to the standard input of less. Everything that ls writes to the standard output will become available for read from standard input in less.

thing1 | thing2 does the same thing as thing1 > temp_file && thing2 < temp_file(22)

When a shell session is closed, the history of that session is updated to the history file. The name of this file is .bash_ history, and it is created in the home directory of the user who started a specific shell session. Notice that the history file is closed only when the shell session is closed; until that moment, all commands inthe history are kept in memory.(24)

Type history to show a list of all commands in the bash history.(26)

Type !number to execute a command with a specific number from history. (28)

Type !sometext to execute the last command that starts with sometext. Notice that this is a potentially dangerous command because the command that was found is executed immediately!(28)

An important concept when working with vim is that it uses different modes. Two of them are particularly important: command mode and input mode. These modes often cause confusion because in command mode you can just enter a command and you cannot change the contents of a text file. To change the contents of a text file, you need to get to input mode.

VIM COMMANDS:
ESC : Switches from input mode to command mode. Use this before typing any command.

i,a : Switches from command mode to input mode at (i) or after (a) the current cursor position.(30)

o : Opens a new line below the current cursor position and goes to input mode.

:wq! : Writes the current file and quits.

:q! : quits.

:w filename : Writes the current file with a new filename.

dd : Deletes the current line.

yy : Copies the current line.

p : paste the current selection

v : Enters visual mode, which allows you to select a block of text using the arrow keys. Use d to cut, or y to copy the selection. 

u : Undoes the last command. Repeat as often as necessary. 

Ctrl+r Redoes the last undo. 

gg Goes to the first line in the document. 

G Goes to the last line in the document.

/text Searches for text from the current cursor position forward. 

?text Searches for text from the current cursor position backward. 

^ Goes to the first position in the current line. 

$ Goes to the last position in the current line. 

!ls Adds the output of ls (or any other command) in the current file.

:%s/old/new/g : Replaces all occurrences of old with new.

an environment is created to ensure that all that is happening is happening the right way. This environment consists of variables that define the user environment, such as the $PATH variable discussed earlier.

The advantage for scripts and programs of working with variables is that the program only has to use the name of the variable without taking interest in the specific value that is assigned to the variable. Because the needs for different users are different, the variables that are set in a user environment will differ.

When a user logs in, an environment is created for that user automatically. This happens based on four different files where some script code can be specified and where variables can be defined for use by one specific user: (56)

Non interactive shell : commands run in backend or through scripts

■ /etc/profile: This is the generic file that is processed by all users upon login. (System wide variables)(only interactive)
■ /etc/bashrc: This file is processed when subshells are started. (System wide command aliases and functions )(both inter and non interactive)
■ ~/.bash_profile: In this file, user-specific login shell variables can be defined, user specific env varibles
■ ~/.bashrc: In this user-specific file, subshell variables can be defined, aliases and functions

As you have seen, in these files a difference is made between a login shell and a subshell. A login shell is the first shell that is opened for a user after the user has logged in. From the login shell, a user may run scripts, which will start a subshell of that login shell. Bash allows for the creation of a different environment in the login shell and in the subshell but to synchronize settings; by default the subshell settings are included when entering a login shell.

Bash offers an option to include messages in the /etc/motd and the /etc/issue files. Messages in /etc/motd display after a user has successfully logged in to a shell. (Notice that users in a graphical environment do not see its contents after a graphical login.) Using /etc/motd(message of the day) can be a convenient way for system administrators to inform users.(60)

Another way to send information to users is by using /etc/issue. The contents of this file display before the user logs in. This provides an excellent means of specifying specific login instructions to users who are not logged in yet.

To find information in man pages, you can search the mandb database by using apropos or man -k. If the database is current, getting access to the information you need is easy. Just type man -k, followed by the keyword you want to search for.(62)

Instead of using man -k, you can use the apropos command. This command is equivalent to man -k.

While using man -k to find specific information from the man pages, you’ll sometimes really get a lot of information. If that happens, it might help to filter down the results a bit by using grep. But if you want to do that, it is important that you know what you are looking for. 
Man pages are categorized in different sections. The most relevant sections for system administrators are as follows 
■ 1: Executable programs or shell commands 
■ 5: File formats and conventions 
■ 8: System administration commands 

So, if you are looking for the configuration file that has something to do with passwords, use man -k password | grep 5, or if you are looking for the command that an administrator would use to create partitions, use man -k partition | grep 8.

Another useful man option is -f. The command man -f <somecommand> displays a short description of the item as found in the man database.(64)

When using the man -k command, the mandb database is consulted. It can sometimes happen that you are looking for something that should obviously be documented but you cannot find anything anyway and all you get is “nothing appropriate.” If that happens, you might need to update the man database.

Just run the mandb command as root without any arguments. It will see whether new man pages have been installed and update the man database accordingly.(62)



/        The root directory. This is where the file system tree starts. 

/bin     In here, you find executable programs that are needed to repair a system in a minimal troubleshooting mode. This directory is              essential during boot. 

/boot    Contains all files and directories that are needed to boot the Linux kernel. 

/dev     Device files that are used for accessing physical devices. This directory is essential during boot. 

/etc     Contains configuration files that are used by programs and services that are used on your server. This directory is essential              during boot. 

/home    Used for local user home directories. 

/lib, /lib64         Shared libraries that are used by programs in /boot, /bin and /sbin. 

/media, /mnt         Directories that are used for mounting devices in the file system tree. 

/opt     This directory is used for optional packages that may be installed on your server. (80)

/proc    This directory is used by the proc file system. This is a file system structure that gives access to kernel information. 

/root    The home directory of the root user. 

/run      Contains process and user specific information that has been created since the last boot. 

/sbin     Like /bin, but for system administration commands that are not necessarily needed by regular users.

/srv      Directory that may be used for data that is used by services like NFS, FTP and HTTP . 

/sys      Used as an interface to different hardware devices that is managed by the Linux kernel and associated processes. 

/tmp      Contains temporary files that may be deleted without any warning during boot. 

/usr      Directory that contains subdirectories with program files, libraries for these program files and documentation about them. Typically, many subdirectories exist in this directory that mimic the contents of the / directory. The contents of /usr are not required during boot. 

/var      Directory that contains files which may change in size dynamically, such as log files, mail boxes, and spool files.

/bin
    This directory contains executable programs which are needed
    in single user mode and to bring the system up or repair it.

/sbin
    Like /bin, this directory holds commands needed to boot the 
    system, but which are usually not executed by normal users.

/usr/bin
    This is the primary directory for executable programs. Most
    programs executed by normal users which are not needed for 
    booting or for repairing the system and which are not
    installed locally should be placed in this directory.

/usr/local
    This is where programs which are local to the site typically
    go.

/usr/local/bin
    Binaries for programs local to the site.

/usr/local/sbin
    Locally installed programs for system administration.

A Linux file system is presented as one hierarchy, with the root directory (/) as its starting point. This hierarchy may be distributed over different devices and even computer systems that are mounted into the root directory.

By configuring a device as a dedicated mount, it is also possible to use specific mount options that can restrict access to the device. Some directories are commonly mounted on dedicated devices:

/boot: This directory is often mounted on a separate device because it required essential information your computer needs to boot. As the root directory (/) is often on a Logical Volume Manager (LVM) logical volume, from which Linux cannot boot, the kernel and associated files need to be stored separately on a dedicated /boot device. 

/var: This directory is often on a dedicated device because it grows in a dynamic and uncontrolled way. By putting it on a dedicated device, you can ensure that it will not fill up all storage on your server. 

/home: This directory often is on a dedicated device for security reasons. By putting it on a dedicated device, it can be mounted with specific options to enhance the security of the server. When reinstalling the operating system, it is an advantage to have home directories in a separate file system. The home directories can then survive the system reinstall. 

/usr: This directory contains operating system files only, to which normal users normally do not need any write access. Putting it on a dedicated device allows administrators to configure it as a read-only mount.

System programs are stored in /bin, user programs in /usr/bin

The mount command gives an overview of all mounted devices. To get this information, the /proc/mounts file is read, where the kernel keeps information about all current mounts.

The df -Th command was designed to show available disk space on mounted devices; it includes most of the system mounts. Because it will look on all mounted file systems, it is a convenient command to get an overview of current system mounts. The -h option summarizes the output of the command in a human-readable way, and the -T option shows which file system type is used on the different mounts.

Mounted on: The directory the device currently is mounted on.

The findmnt command shows mounts and the relation that exists between the different mounts. Because the output of the mount command is a bit overwhelming, you may like the output of findmnt.

Wildcards:

* Refers to an unlimited number of all characters. ls *, for instance, shows all files in the current directory (except those that have a name starting with a dot). 

? Used to refer to one specific character that can be any character. ls c?t would match cat as well as cut. 

[auo] Refers to one character that may be selected from the range that is specified between square brackets. ls c[auo]t would match cat, cut, and cot.

An absolute filename, or absolute pathname, is a complete path reference to the file or directory you want to work with. This pathname starts with the root directory, followed by all subdirectories up to the actual filename. No matter what your current directory is, absolute filenames will always work. An example of an absolute filename is /home/lisa/file1.

A relative filename is relative to the current directory as shown with the pwd command. It contains only the elements that are required to get from the current directory up to the item you need. Suppose that your current directory is /home (as shown by the pwd command). When you refer to the relative filename lisa/ file1, you are referring to the absolute filename /home/lisa/file1 .

hierarchy. Imagine you are logged in as root and you want to copy the file / home/lisa/file1 to the directory /home/lara. A few solutions would work: 

■ Use cp /home/lisa/file1 /home/lara. Because in this command you are using absolute pathnames, this command will work at all times. 

■ Make sure your current directory is /home and use cp lisa/file1 lara. Notice that both the source file and the destination file are referred to as relative filenames and for that reason do not start with a /. 

■ If the current directory is set to /home/lisa, you could also use cp file1 ../lara. In this command, the name of the target file uses .., which means go up one level. The .. is followed by /lara, so the total name of the target file would be interpreted as “go up one level” (so you would be in /home), and from there, look for the /lara subdirectory.

ls -l Shows a long listing, which includes information about file properties, such as creation date and permissions. 

ls -a Shows all files, including hidden files(.). 

ls -lrt This is a very useful command. It shows commands sorted on modification date. You’ll see the most recently modified files last in the list. 

ls -d Shows the names of directories, not the contents of all directories that match the wildcards that have been used with the ls command. 

ls -R Shows the contents of the current directory, in addition to all of its subdirectories; that is, it Recursively descends all subdirectories.

A hidden file on Linux is a file that has a name that starts with a dot. Try the following: touch .hidden. Next, type ls. You will not see it. Then type ls -a. You’ll see it.

With the cp command, you can also copy an entire subdirectory, with its contents and everything beneath it. To do so, use the option -R, which stands for recursive.

While using the cp command, permissions and other properties of the files are to be considered. Without extra options, you risk permissions not being copied. If you want to make sure that you keep the current permissions, use the -a option, which has cp work in archive mode. This option ensures that permissions and all other file properties will be kept while copying. So, to copy an exact state of your home directory and everything within it to the /tmp directory, use cp -a ~ /tmp.

To move files, you use the mv command. This command removes the file from its current location and puts it in the new location. You can also use it to rename a file

On RHEL 7, the rm command prompts for confirmation. If you do not like that, you can use the -f option. Make sure that you know what you are doing when using this option, because after using it, there is no way back but the backup tape!

cp -a ../newfile/ .

a file system is divided into two parts - the inodes and data blocks

Linux stores administrative data about files in inodes. Every file on Linux has an inode, and in the inode, important information about the file is stored: 
■ The data block where the file contents are stored 
■ The creation, access, and modification date 
■ Permissions 
■ File owners Just one important piece of information is not stored in the inode: the name.

You see, the directory is just a table that contains the filenames in the directory, and the matching inode. Think of it as a table, and the first two entries are always "." and ".." The first points to the inode of the current directory, and the second points to the inode of the parent directory. 

When you create a hard link, it just created a new name in the table, along with the inode, without moving the file. When you move a file (or rename it), you don't copy the data. That would be Slow. You just create the (name,inode) entry in a new directory, and delete the old entry in the table inside the old directory entry. In other words, moving a gigabyte file takes very little time. In the same way, you can move/rename directories very easily. That's why "mv /usr /Old_usr" is so fast, even though "/usr" may contain (for example) 57981 files.

You can see this "inode" stuff if you use the "ls -i" option. It lists the inode number. find(1) can use it as well. Let's also use the "-d" option to list information about the directory, rather than the contents of the directory.

We are used to thinking about a directory containing files. This is really an illusion. Directories do not contain files. The data of the files is not stored in the directory.

A directory is really just a file.

When you create a file, you give it a name. Basically, this name is a hard link. On a Linux file system, multiple hard links can be created to a file. This can be useful, because it enables you to access the file from multiple different locations. Some restrictions apply to hard links though: 
■ Hard links must exist all on the same device. 
■ You cannot create hard links to directories. 
■ The number of aliases the original file has. When the last name is removed, the contents are also removed.
 
A symbolic link (also referred to as soft link) does not link directly to the inode but to the name of the file. This makes symbolic links much more flexible, but it also has some disadvantages. The advantage of symbolic links is that they can link to files on other devices, as well as on directories. The major disadvantage is that when the original file is removed, the symbolic link becomes invalid and does not work any longer.

mv doesnt change the inode

Hard link is copy with automatic sync(mv with replica and in sync), while copy will change the inode

Soft link is pointing to the file so its obvious with automatic sync, inode changes

In the output of the ls -l command, the first character is an l if the file is a symbolic link.

Use the ln command to create links.

Use rm link. This removes the link. (Do not use -r or -f to remove links, even if they are subdirectories.)

c Creates an archive. 
v Shows verbose output while tar is working. 
f Used to specify the name of the tar archive that is to be used. Without using this option, the default destination is STDIN for -x and STDOUT for -c. 
t Shows the contents of an archive. 
z Compresses/decompresses the archive while creating it, by using gzip. 
j Compresses/decompresses the archive by using bzip2. 
x Extracts an archive. 
u Updates an archive; only newer files will be written to the archive. 
C Changes the working directory before performing the command. 
r Appends files to an archive.

To create an archive, you use the tar -cf archivename.tar /files-you-want-toarchive command. If you want to see what is happening, use the -v option as well.

To add a file to an archive, you use the -r options. Use for instance tar -rvf /root/homes.tar /etc/hosts to add the /etc/hosts file to the archive.

To update a currently existing archive file, you can use the -u option. So, use tar -uvf /root/homes.tar /home to write newer versions of all files in /home to the archive.

less  Opens the text file in a pager, which allows for easy reading of the text file
cat   Dumps the contents of the text file on the screen
head   Shows the first 10 lines of the text file
tail   Shows the last 10 lines of the text file
cut   Used to filter specific columns or characters from a text file
sort   Sorts contents of a text file
wc   Counts the number of lines, words, and characters in a file

From less, you can use the PageUp and PageDown keys on your keyboard to browse through the file contents. Seen enough? Then you can press q to quit less. Also very useful is that you can easily search for specific contents in less using /sometext for a forward search and ?sometext for a backward search. Repeat the last search by using n. 

Type ps aux | less. This sends the output of the ps aux command (which shows a listing of all processes) to less.

The less utility is useful to read long text files. If a text file is not that long, you are probably better off using cat. This tool just dumps the contents of the text file on the terminal it was started from. This is convenient is the text file is short. If

If a text file contains much information, it can be useful to filter the output a bit. You can use the head and tail utilities to do that. Using head on a text file will show by default the first 10 lines of that file. Using tail on a text file shows the last 10 lines by default. You can adjust the number of lines that are shown by adding -n followed by the number you want to see. So, tail -n 5 /etc/passwd shows the last five lines of the /etc/passwd file.

Another useful option that you can use with tail is -f. This option starts by showing you the last 10 lines of the file you’ve specified, but it refreshes the display as new lines are added to the file. This is convenient for monitoring log files. The command tail -f /var/log/messages is a common command to show in real-time messages that are written to the main log file /var/log/messages.

When combining tail and head, you can do smart things as well. Suppose, for instance, that you want to see line number 11 of the /etc/passwd file. To do that, use head -n 11 /etc/passwd | tail -n 1.

When working with text files, it can be useful to filter out specific fields. Imagine that you need to see a list of all users in the /etc/passwd file. In this file, several fields are defined, of which the first contains the name of the users who are defined. To filter out a specific field, the cut command is useful. To do this, use the -d option to specify the field delimiter followed by -f with the number of the specific field you want to filter out. So, the complete command is cut -d : -f 1 /etc/passwd if you want to filter outthe first field of the /etc/passwd file.

Another very useful command to use on text file is sort. As you can probably guess, this command sorts text. If you type sort /etc/passwd, for instance, the content of the /etc/passwd file is sorted in alphabetic order. You can use the sort command on the output of a command also, as in cut -f 1 -d : /etc/passwd | sort, which sorts the contents of the first column in the /etc/passwd file.

By default, the sort command sorts in alphabetic order. In some cases, that is not convenient because the content that needs sorting may be numeric or in another format. The sort command offers different options to help sorting these specific types of data. Type, for instance, cut -f 2 -d : /etc/passwd | sort -n to sort the second field of the /etc/passwd file in numeric order. It can be useful also to sort in reverse order; if you use the command du -h | sort -rn, you get a list of files sorted with the biggest file in that directory listed first.

You can also use the sort command and specify which column you want to sort. To do this, use sort -k3 -t : /etc/passwd, for instance, which uses the field separator : to sort the third column of the /etc/passwd file.

sort process based on memory and get top 5 results

When working with text files, you sometimes get a large amount of output. Before deciding which approach works best in a specific case, you might want to have an idea about the amount of text you are dealing with. In that case, the wc command is useful. In its output, this command gives three different results: the number of lines, the number of words, and the number of characters.

Now suppose that you are looking for the user anna. In that case, you could use the general regular expression parser grep to look for that specific string in the file /etc/ passwd by using the command grep anna /etc/passwd.

To show only lines that start with the text you are looking for, you can use the regular expression ^

Another regular expression that relates to the position of specific text in a specific line is $, which states that the line ends with some text. For instance, the command grep ash$ /etc/passwd shows all lines in the /etc/passwd file that end with the text ash.






tail -f /var/log/secure. This opens a trace on the file /var/log/secure, where you can monitor security events in real time.

A convenient alternative to using the Alt+Function key sequences is offered by the chvt command. This command enables you to switch to a different virtual environment directly from the current environment.

Virtual terminals are mentioned by tty and are found in /dev/

For terminal windows that are started from a graphical environment, pseudo terminals are started. These pseudo terminals are referred to using numbers in the /dev/ pts directory. (131)

To issue a proper reboot, the systemd process has to be alerted. The systemd process is the first process that was started when the server was started, and it is responsible for managing all other processes, directly or indirectly. As a result, on system reboots or halts, the systemd process needs to make sure that all these processes are stopped.

systemctl reboot or reboot 
■ systemctl halt or halt 
■ systemctl poweroff or poweroff

In some cases, these commands might not work. If that is the case, there is an emergency reset option as well. Using this option may prove useful if the machine is not physically accessible. To force a machine to reset, you can type echo b > /proc/sysrq-trigger. This command immediately resets the machine without saving anything. Notice that this command should be used only if there are no other options!

On the remote server that you want to access, the sshd service must be running and offering services at port 22, and it should not be blocked by the firewall.

If you have configured the sshd process to offer its services on a different port, use ssh -p followed by the port number you want to connect to.

After connecting, you will be prompted for a password if a default configuration is used.

An alternative way of specifying the user account is by using the option -l username.

On some occasions, using ssh to get access to a server will be slow. If you want to know why, use the -v option with the ssh command.

You have noticed that while using SSH to connect to the remote server a security message was displayed. This is because the remote server has never been contacted before and therefore there is no way to verify the identity of the remote server. After connecting to the remote server, a public key fingerprint is stored in the file ~/.ssh/ known_hosts .

The next time you connect to the same server, this fingerprint is checked with the encryption key that was sent over by the remote server to initialize contact. If the fingerprint matches, you will not see this message anymore.

In some cases, the remote host key fingerprint does not match the key fingerprint that is stored locally. That is a potentially dangerous situation. Instead of being connected to the intended server, you might be connected to the server of an evildoer. It does, however, also happen if you are connecting to an IP address that you have been connected to before, but this IP address is now in use by a different server. In that case, you just have to remove the key fingerprint from the ~/.ssh/known_hosts file on the client computer.

As an administrator, you can also create a systemwide configuration that allows you to use “X forwarding,” which is starting graphical applications through an SSH session. As root, open the configuration file /etc/ssh/ssh_config and make sure it includes the following line: ForwardX11 yes

If a host is running the sshd service, that service can also be used to securely transfer files between systems. To do that, you can use the scp command.

You can also use scp to copy an entire subdirectory structure. To do so, use the -r command, as in the following command: scp -r server2:/etc/ /tmp

Notice that the scp command can be configured to connect to a non-default SSH port also. It is a bit confusing, but to do this with the scp command, you need the -P option followed by the port number you want to connect to. Notice that ssh uses -p (lowercase) to specify the port it needs to connect to; the scp command uses an uppercase -P.

The only thing you need to do to enable key-based login is to create a key pair. When using public/private key-based authentication, the user who wants to connect to a server generates a public/private key pair. The private key needs to be kept private and will never be distributed. The public key is stored in the home directory of the target user on the SSH server.

When authenticating using key pairs, the user generates a hash derived from the private key. This hash is sent to the server, and if on the server it proves to match the public key that is stored on the server, the user is authenticated.

When creating a public/private key pair, you are prompted for a passphrase. If you want maximal security, you should enter a passphrase.

After copying over the public key to the remote host, it will be written to the ~/.ssh/ authorized_keys file on that host. Notice that if multiple users are using keys to log in with that specific account, the authorized_keys file may contain a lot of public keys. Make sure never to overwrite it because that will wipe all keys that are used by other users as well!

To create a key pair, use the ssh-keygen command. The ssh-copy-id command is next used to copy the public key over to the target server.

but the screen command is a useful command that allows you to open multiple terminal sessions, even if you are not in a graphical session. It does not just allow you to run multiple terminals but also allows you to share a session with other users, or to attach and detach to remote terminal sessions.

The screen command is particularly useful when used from an SSH session. You can start a task that takes a long time from a screen session, detach from it, and attach to it later. The command continues running, even if you are going home and shut down your computer. The next day, you can easily attach to the screen session again to complete the task.

If while trying to attach to a screen session you get a message that multiple screen sessions are currently running, you need to be more specific. To find out which screen sessions currently are running, use the screen -ls command. This command shows you all screen sessions that are currently running. In Listing 5.2 , you can see how multiple screen sessions are detached from, and how the screen -r command gives a list of all currently available screen sessions, from which you can select the screen session you want to connect to by adding the number of the screen session to the screen -r command.

On Linux, there are two ways to look at system security. There are privileged users, and there are unprivileged users. The default privileged user is root.

To get information about a user account, you can use the id command.

You can also use it on other user accounts to get details about those accounts.

Methods to Run Tasks with Elevated Permissions 

su Opens a subshell as a different user, with the advantage that only in the subshell commands are executed as root 

sudo Allows you to set up an environment where specific tasks are executed with administrative privileges 

PolicyKit Allows you to set up graphical utilities to run with administrative privileges

If just the command su is typed, the username root is implied. But su can be used to run tasks as another user as well. Type su linda to open a subshell as the user linda,

When using su, a sub shell is started. This is an environment where you are able to work as the target user account, but environment settings for that user account have not been set. If you need complete access to the entire environment of the target user account, you can use su - to start a login shell. If you start a login shell, all scripts that make up the user environment are processed, which makes you work in an environment that is exactly the same as when logging in as that user.

Instead of using the root user account, unprivile7.6ged users can be configured for using administrator permissions on specific tasks by using sudo. When sudo is configured, ordinary users have sudo privileges and to use these privileges, they will start the command using sudo. So, instead of using commands like useradd as the root user, you use an ordinary user account and type sudo useradd.

The wheel group is a special user group used on some Unix systems to control access to the su or sudo command, which allows a user to masquerade as another user

When creating Linux users during the installation process, you can select to grant administrator permissions to that specific user. If you select to do so, the user will be able to use all administrator commands using sudo. It is also possible to set up sudo privileges after installation. To do that in a very easy way, you have to accomplish a simple two-step procedure: 

1. Make the administrative user account member of the group wheel by using usermod -aG wheel user. 
2. Type visudo and make sure the line %wheel ALL=(ALL) ALL is included.

Most administration programs with a graphical user interface use PolicyKit to authenticate as the root user. If a normal user who is not a member of the group wheel accesses such an application, he will be prompted for authentication. If a user who is a member of the group wheel opens a PolicyKit application, he will have to enter his own password.

On a typical Linux environment, two kinds of user accounts exist. There are user accounts for the people who need to work on a server and who need limited access to the resources on that server. These user accounts typically have a password that is used for authenticating the user to the system. There are also system accounts that are used by the services the server is offering. Both user accounts share common properties, which are kept in the files /etc/passwd and /etc/shadow.

etc/passwd format:

username:password:UID:GID:comment field:homedirectory:shell

This is the program that is started after the user has successfully connected to a server. For most users this will be /bin/bash, the default Linux shell. For system user accounts, it will typically be a shell like /sbin/nologin. The /sbin/nologin command is a specific command that silently denies access to users (to ensure that if by accident an intruder logs in to the server he cannot get any shell access). You can create a file with the name /etc/nologin.txt that contains a message that will be displayed when a user who has /sbin/ nologin as its shell tries to log in.

etc/shadow show the properties for password 

The settings in this file are used to define the validity of the password. Typical for /etc/shadow is that no one except the superuser root and processes running with root permissions, such as the authentication mechanisms on the server, have permissions to access it, which makes sense as it contains all the information that is required for connecting to a system.

There are many solutions for creating users on a Linux server. To start, you can edit the contents of the /etc/passwd and /etc/shadow files directly (with the risk of making an error that could make logging in impossible to anyone; so better just do not). There is also useradd. useradd is the utility that you should use for creating users. To remove users, you can use the userdel command. Use userdel -r to remove a user, including the complete user environment.

If you insist on modifying the configuration files directly, you should use vipw. This command opens an editor interface on your configuration files, and more important, it sets the appropriate locks on the configuration files to prevent corruption. It does not check syntax, however, so make sure that you know what you are doing because even by making a typo you might still severely mess up your server. If you want to use this tool to modify the /etc/shadow file, use vipw -s. To edit the contents of the /etc/group file where groups are defined, a similar command with the name vigr exists.

Use, for instance, the command useradd -m -u 1201 -G sales,ops linda to create a user linda who is a member of the groups sales and ops with UID 1201 and add a home directory to the user account as well.

If when creating user accounts you tell your server to add a home directory as well (for instance, by using useradd -m), the content of the “skeleton” directory is copied to the user home directory. The skeleton directory is /etc/skel, and it contains files that are copied to the user home directory at the moment this directory is created

























Shell jobs are commands started from the command line. They are associated with the shell that was current when the process was started. Shell jobs are also referred to as interactive processes. 

■ Daemons are processes that provide services. They normally are started when a computer is booted and often (but certainly not in all cases) they are running with root privileges.

use & to run process in background

fg command to make process run in forground

Ctrl+Z to temporarily stop the job. This

Once paused, it can be continued as a background job using the bg command.

Ctrl+C. This stops the current job and removes it from memory.

A related keystroke combination is Ctrl+D, which sends the End Of File (EOF) character to the current job. The result is that the job stops waiting for further input so that it can complete what it was currently doing.

bg 3

So many process--> many individual threadss--> cant manage individual threads-->can manage processes

ps aux(short summary of active processes) | head : kernel threads mentioned by square branckets

ps to get command in processes : ps ef

ps fax : to show parent child relationship

nice -n 5 dd if=/dev/zero of=/dev/null &

renice -n 10 -p 1234

Kill : SIGTERM --> SIGKILL 

kill -9 : SIGKILL

top : process based on consuption














NETWORKING :

TCP : Reliable and guranted delivery ssh, smptp mail , web
UDP : fast and delivery doesnt count Mdia steaming, games update

network card : eth0, eth1 : based on first card detection

card based on firmware, device type, : en: ethernet : wl : WLAN wn: WWAN --> next part is type of adapter : o : onboard s: hotplug spot p: pci location --> next is ID 

eno16777734 : onboard ethernet  p4p1 : PCI slot 4 port 1

socket : endpoint to send and recieve traffic within a node 
port : ip port combination is open to world which define services--> redirect to socket for specific service 

netstat : show both internate connections and socket connections

netstat -upn/l : internt connection-->programs-->open ports-->listening or not

ip addr show : to show network card connections with ip address
ip route show : routing of all ips to default gateway : same can be show with the help of netstat -r
 
if  you want to add privet ip address to your device : ip addr  add

use of : ip: non persisten: for persistent changes : use network manager : nm

nm : to add ip, host name

how to setup hostname : etc/hostsname

PROCESSES :

2 types : shell and daemon(started during boot 

bg jobs : not neeeded much user interaction

command: 
    fg: to make running bg job in fg
    ctrl+Z: to stop fg job temp. in memory, than use bg to run it in background
    ctrl+c: to cancel job
    ctrl+D: to complete the job withought any much further inputs


















